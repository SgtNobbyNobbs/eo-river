# -*- coding: utf-8 -*-
"""
.. module:: boundary
    :platform: Windows
    :synopsis:
    
.. moduleauthor:: Koen Berends <koen.berends@deltares.nl>
.. modified by::  Dimitris Zervakis

Boundaries can be defined by edges or vertices. All data is loaded as vertices. 
If the input data is sorted, connectivity between vertices can be assumed. In 
this case,  (???). 


Load data from file, perform basic operations, write to file. 


"""
import os
import numpy as np
import requests
import pyproj
import shapefile
import matplotlib.pyplot as plt
from datetime import datetime


class Polygon():
    '''
    Loaded data is accessible via the 'data' attribute:
    
    >>> # Landboundary file
    >>> Polygon.load('example.ldb')
        -- or --
    >>> # ESRI shapefile
    >>> Polygon.load('example.shp')
    
    Also .xyz files can be loaded as sample data.

    '''    
    def __init__(self):
        #Initial CRS is unknown. If known, it should be specified with transform_coordinates() function
        self._CoordinateSystem = 'unknown'
        self._CoordinateSystemInfo = ''
        self._CRSstring = ''
        # Initialize data structures
        self._HasData = False
        self.data = {'meta' : [],'data' : {}}
        self._implemented_extensions = {'.ldb':self.__load_ldb,
                                        '.xyz':self.__load_sample, #deprecated
                                        '.shp':self.__load_shape}
                                        
    
    
    def save(self, polygon, parts='all', polygon_name='polygon', outputfile='polygon', fileformat='ldb'):
        '''
        Save selected parts of a loaded polygon to a new polygon with a new name. 
        
            polygon: The polygon to save (string).
            parts: Parts of the polygon to save given as a list of ids. 'all' keyword saves all of them.
            polygon_name: The name which appears for the polygon in the file (string).
            outputfile: Name of output file (string).
            fileformat: Type of file output (string).
        
        File is saved to .ldb or .shp
        '''

        #Formulate the path correctly (Windows)
        outputfile = outputfile.encode('string-escape')
        outputfile = outputfile.replace('\\','/')
        outputfile = outputfile.replace('//','/')
        #only .ldb and .shp are allowed
        supported_extensions = {'ldb':'.ldb', 'landboundary': '.ldb', 
                                'shp':'.shp', 'shape':'.shp', 'shapefile':'.shp'}
        try:
            extension = supported_extensions[fileformat]
        except KeyError:
            print 'Error: unsupported fileformat'
            return
            
        print "Trying to save to: "+str(outputfile+extension)
        
        if parts == 'all':
            parts = range(len(self.data['data'][polygon]['parts']))
        print "Ignoring z values."
        
        #save as LANDBOUNDARY
        if extension == '.ldb':
            x=list()
            y=list()
            for partnumber in parts:
                part = self.data['data'][polygon]['parts'][partnumber]
                #include last lines
                x.extend(part['x']+[999.999])
                y.extend(part['y']+[999.999])
            del x[-1]
            del y[-1]
            dim = len(x)
            with open(outputfile+extension, 'w') as f:
                f.write('* Polygon file. Generated by RAT-IN on '+datetime.now().strftime("%Y-%m-%d %H:%M:%S")+'\n')
                f.write('*column 1 = x\n')
                f.write('*column 2 = y\n')
                f.write(polygon_name+'\n')
                f.write(str(dim)+' 2\n')
                for i in range(0,len(x)):
                    f.write('   '+str('%.17E'%x[i])+'   '+str('%.17E'%y[i])+'\n') #scientific notation
        #save as SHAPEFILE
        else:
            print "Warning: All geometries will be outputted as simple polygons.\n"
            w = shapefile.Writer(shapeType=5)
            w.autoBalance = 1
            w.field("ID","N",len(str(len(parts))),0)
            for partnumber in parts:
                part = self.data['data'][polygon]['parts'][partnumber]
                w.poly(parts = [[list(xy) for xy in zip(part['x'],part['y'])]])
                w.record(partnumber)
            w.save(outputfile+extension)
            if self._CoordinateSystem != 'unknown':
                crs = self._CoordinateSystem.split(':')
                esristr= 'http://spatialreference.org/ref/{0}/{1}/esriwkt/'.format(crs[0].lower(),crs[1])
                line = str(requests.get(esristr).text)
                prj = open("{0}.prj".format(outputfile),'w')
                prj.write(line)
                prj.close()
        
        print "Save successful.\n"



    def clear(self):
        '''
        clear loaded polygon
        '''
        self.data.clear()    
        self.data = {'meta' : [],'data' : {}}


        
    def load(self, inputfile):
        '''
        This method checks the input file and calls the appropriate i/o method. 
        
        Currently the following formats are supported:
        
        * Landboundary (*.ldb): Outputted from Delft3D text file.
        * Sample file (*.xyz): Text file with Cartesian coordinates(x,y) and possible elevation(z) [depricated].
        * Shapefile (*.shp): ESRI vector data format file.
        
        '''
        
        #check
        inputfile = str(inputfile)
        if not(os.path.isfile(inputfile)):
            print "ERROR: Input file not found!"
            return
        
        #Formulate the path correctly (Windows)
        inputfile = inputfile.encode('string-escape')
        inputfile = inputfile.replace('\\','/')
        inputfile = inputfile.replace('//','/')
        print "Trying to load: "+str(inputfile)
        
        # Extract file extension
        extension = os.path.splitext(inputfile)[-1]

        # Test if extension is implemented
        try: 
            self._implemented_extensions[extension]            
        except KeyError:
            print('Extension not recognized. Invalid input file.')
        self._implemented_extensions[extension](inputfile)
        print "Load successful.\n"        
        


    def plot(self, fignum=1, filled=True, block = False, hold=False):
        '''
        Plot loaded data with matplotlib. 
        '''
        try:
            plt.close(fignum)
            fig = plt.figure(fignum)
            fig.clf()
            fig.hold(hold)
            ax = fig.add_subplot(111)
            for line in self.data['data']:
                if not line == 'parts':
                    data  = self.data['data'][line]
                    if filled:
                        ax.fill(data['x'],data['y'],color = [0.8,0.8,0.8]) #grey
                    ax.plot(data['x'],data['y'],color = [0.1,0.1,0.1])
                    if not(self._CoordinateSystem == 'unknown'):
                        plt.title('Coordinate System: '+self._CoordinateSystem)
                    plt.axis('equal')
            xlim = ax.get_xlim()
            ylim = ax.get_ylim()
            
            # Plot latitude/longitude lines
            if not(self._CoordinateSystem == 'unknown'):
                wgs84 = pyproj.Proj(r'+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')
                #curproj = pyproj.Proj(init = self._CoordinateSystem)
                curproj = pyproj.Proj(self._CRSstring)
                curproj_x_min, curproj_x_max, curproj_y_min, curproj_y_max = self.get_bounding_box()
                wgs84_min = pyproj.transform(curproj,wgs84,curproj_x_min,curproj_y_min)
                wgs84_max = pyproj.transform(curproj,wgs84,curproj_x_max,curproj_y_max)
                
                #? more precise to the area of interest: lat/lon in 0.05 cells                
                lonbounds = np.arange( np.int(np.floor(wgs84_min[0]*10.0))/10.0 , np.int(np.ceil(wgs84_max[0]*10.0))/10.0, 0.05 )
                latbounds = np.arange( np.int(np.floor(wgs84_min[1]*10.0))/10.0 , np.int(np.ceil(wgs84_max[1]*10.0))/10.0, 0.05 )
                #lonbounds = np.arange(np.floor(wgs84_min[0]),np.ceil(wgs84_max[0]),0.05)
                #latbounds = np.arange(np.floor(wgs84_min[1]),np.ceil(wgs84_max[1]),0.05)
                LO,LA = np.meshgrid(lonbounds,latbounds)
                #plot lines of lat/lon
                for i in range(LO.shape[0]):
                    x,y = pyproj.transform(wgs84,curproj,LO[i,:],LA[i,:])
                    ax.plot(x,y,'--',color=[0.7,0.7,0.7])
                for i in range(LO.shape[1]):
                    x,y = pyproj.transform(wgs84,curproj,LO[:,i],LA[:,i])
                    ax.plot(x,y,'--',color=[0.7,0.7,0.7])
                    
            ax.set_xlim(xlim)
            ax.set_ylim(ylim)
            if block:
                plt.ioff()
            else:
                plt.ion()
            fig.show()
                
        except KeyError:
            print 'First load data'



    def transform_coordinates(self, new_coordinatesystem):
        '''
        Transform coordinates of loaded data
        '''
        new_coordinatesystem = str(new_coordinatesystem)
        if self._HasData:
            valid, info = self._validate_coordinatesystem(new_coordinatesystem)
            if valid:
                if self._CoordinateSystem != 'unknown':
                    for line in self.data['data']:
                        originaldata = [self.data['data'][line]['x'],self.data['data'][line]['y']]
                        transformeddata, info = self._transformer(originaldata, self._CoordinateSystem, new_coordinatesystem)
                        self.data['data'][line]['x'] = transformeddata[0]
                        self.data['data'][line]['y'] = transformeddata[1]
                        jump = 0
                        for part in range(len(self.data['data'][line]['parts'])):
                            length = len(self.data['data'][line]['parts'][part]['x'])
                            self.data['data'][line]['parts'][part]['x'] = transformeddata[0][jump:jump+length]
                            self.data['data'][line]['parts'][part]['y'] = transformeddata[1][jump:jump+length]
                            jump += length+1
                self._CoordinateSystem = new_coordinatesystem
                self._CoordinateSystemInfo = info
                self._CRSstring = valid
                print 'set coordinate system to '+new_coordinatesystem
            else:
                print 'coordinatesystem '+new_coordinatesystem+' invalid'
        else:
            print 'no data loaded'

            
    def get_bounding_box(self):
        """
        Retrieve the bounding box of the Polygon object.
        Tuple format: (x_min, x_max, y_min, y_max)
        """
        xmin = float('inf')
        xmax = float('-inf')
        ymin = float('inf')
        ymax = float('-inf')
        for polygon in self.data['data']:
            xmin = min(xmin, min(self.data['data'][polygon]['x']))
            xmax = max(xmax, max(self.data['data'][polygon]['x']))
            ymin = min(ymin, min(self.data['data'][polygon]['y']))
            ymax = max(ymax, max(self.data['data'][polygon]['y']))
        return xmin, xmax, ymin, ymax
            
            
    # ----------------------------------------------------------------
    # Static Methods
    # ----------------------------------------------------------------
    @staticmethod
    def _transformer(data, old_system, new_system):
        '''
        Transform data from one coordinate system to another.
        Data should be a list containing two lists of equal length, containing
        x (or lon) and y (or lat) data. 
        '''

        old_system = str(old_system)
        new_system = str(new_system)
        try:
            newsystem = new_system.split(':')
            oldsystem = old_system.split(':')
            
            #Dependence on site: Not all CRS are available as correct proj4 files
            newstring= 'http://spatialreference.org/ref/{0}/{1}/proj4/'.format(newsystem[0].lower(),newsystem[1])
            infostring= 'http://spatialreference.org/ref/{0}/{1}/prettywkt/'.format(newsystem[0].lower(),newsystem[1])
            oldstring= 'http://spatialreference.org/ref/{0}/{1}/proj4/'.format(oldsystem[0].lower(),oldsystem[1])
                                         
            info = requests.get(infostring)
            
            old_proj4_string = str(requests.get(oldstring).text)
            new_proj4_string = str(requests.get(newstring).text)
        except Exception, msg:
            print 'failed getting info from site: '+str(msg) 
            old_proj4_string = '+init='+old_system
            new_proj4_string = '+init='+new_system
        try:
            projection_new = pyproj.Proj(new_proj4_string)
        except:
            print 'Unknown Coordinate system: '+new_system
        try:
            projection_old = pyproj.Proj(old_proj4_string)
        except:
            print 'Unknown Coordinate system: '+old_system
        #transformation        
        sep = np.hstack( (-1, np.where(np.isnan(data[0]))[0], len(data[0])) )
        x,y = [], []
        for s in range(len(sep)-1):
            dataX = data[0][sep[s]+1 : sep[s+1]]
            dataY = data[1][sep[s]+1 : sep[s+1]]
            tempx,tempy = pyproj.transform(projection_old,projection_new,dataX,dataY)
            x.extend(tempx+[np.nan])
            y.extend(tempy+[np.nan])
        del x[-1]
        del y[-1]
        
        return [x,y], info.text

        
        
    @staticmethod
    def _validate_coordinatesystem(new_system):
        '''
        Checker for CRS. 
        Validates the existance of input CRS by querying spatialreference.org.
        '''

        try:
            newsystem = new_system.split(':') 
            infostring= 'http://spatialreference.org/ref/{0}/{1}/prettywkt/'.format(newsystem[0].lower(),newsystem[1])
            #Request information from spatialreference.org
            info = requests.get(infostring).text
            #double check for prj info:
            proj4str = 'http://spatialreference.org/ref/{0}/{1}/proj4/'.format(newsystem[0].lower(),newsystem[1])
            proj4 = str(requests.get(proj4str).text)
            if not proj4 or proj4[:9] == 'Not found' or info[:9] == 'Not found':
                raise Exception('Unable to retrieve projection parameters - empty reference: '+proj4str)
            print 'Coordinate System data succesfully loaded from spatialreference.org'
            valid = proj4
        except Exception,msg:
            print 'Failed getting info from site: '+str(msg) 
            valid = False
            info = 'invalid'
      
        return valid, info

        
    # ----------------------------------------------------------------
    # Private Methods
    # ----------------------------------------------------------------

    def __load_shape(self, inputfile):
        '''
        Reads a shapefile (can be of type polygon or linestring)
        '''
        sf = shapefile.Reader(inputfile)
        if len(sf.shapes()) > 1:
            print "\nWARNING: Input file has multiple geometries."
        #polyline_id hardcoded - no difference in defining different ones
        polyline_id = 'polygon' #?what is 'F001' code in .ldb files generated by QUICKIN?
        try:
            f = os.path.splitext(inputfile)[0]
            prj = open("{0}.prj".format(f), "r")
            self.data['meta'] = prj.read()
        except:
            self.data['meta'] = sf.records()
        cnt = -1
        for shape in sf.shapes():
            cnt += 1
            self.data['data'][polyline_id+str(cnt)] = {'x': [],'y':[],'z':[]}
            self.data['data'][polyline_id+str(cnt)]['parts']= []
            if shape.shapeType not in [3,5]:
                print "\nWARNING: Excluded shape which is neither a polygon nor a linestring.\n"
                continue
            idx = list(shape.parts) + [len(shape.points)]
            for p in range(len(idx)-1):
                x = [s[0] for s in shape.points[idx[p]:idx[p+1]]]
                y = [s[1] for s in shape.points[idx[p]:idx[p+1]]]
                self.data['data'][polyline_id+str(cnt)]['parts'].append({'x':x,'y':y,'z':[]})
                self.data['data'][polyline_id+str(cnt)]['x'].extend(x+[np.nan])
                self.data['data'][polyline_id+str(cnt)]['y'].extend(y+[np.nan])
            del self.data['data'][polyline_id+str(cnt)]['x'][-1]
            del self.data['data'][polyline_id+str(cnt)]['y'][-1]
        self._HasData = True
        sf.shp.close()


        
    def __load_sample(self, inputfile):
        '''
        Reads a XYZ file [deprecated]
        '''
        inputformat = {'format': 'sample',
                       'comment': ['"','!','#','@','$','%','*','<','^','&'],
                       'nanvalues':np.array([-999,999,99999,999999,999.999])}
        self.__parse_file(inputfile,inputformat)
        self._HasData = True



    def __load_ldb(self, inputfile):
        '''
        Reads a landboundary file
        '''
        inputformat = {'format': 'ldb',
                       'comment': ['*'],
                       'nanvalues':np.array([-999,999,99999,999999,999.999])}
        self.__parse_file(inputfile,inputformat)
        self._HasData = True


        
    ##?? Needs to be refined in order to include multipolygons, polygons with holes etc in the future
    def __parse_file(self, inputfile, inputformat):
        '''
        Parser for text files (.ldb,.xyz)
        '''
        nanvalues = inputformat['nanvalues']
        
        with open(inputfile, 'r') as F:
            line_part_number = 0
            if inputformat['format'] == 'sample':
                polyline_id = 'sample'
                self.data['data'][polyline_id] = {'x': [],'y':[],'z':[]}
                self.data['data'][polyline_id]['parts']= [{'x': [],'y':[],'z':[]}]
            #START: Parsing
            for i, line in enumerate(F):
                columnid  = [] #why is it needed/ purpose????
                columnname = []
                words = line.split()
                if not words:
                    continue #skip empty lines
                # For COMMENTS:
                #-Filter out comments and add them as metadata
                #-If first character of first 'word' in line is a comment character:
                if words[0][0] in inputformat['comment']:
                    self.data['meta'].append(line)
                    if inputformat['format'] == 'ldb' and words[0].lower() == '*column':
                        columnid.append(int(words[1]))
                        columnname.append(" ".join(words[3:]))
                    elif inputformat['format'] == 'sample':
                        pass  #ignore samples' lines with comments
                # For DATA:
                #-Locate part seperation and data
                else:
                    #part name
                    if (len(words) == 1) and (inputformat['format'] == 'ldb'):
                        polyline_id = words[0] #change name to the one specified in file
                        #???WHY both??? You can simply store the id of where a part ends
                        self.data['data'][polyline_id] = {'x': [],'y':[],'z':[]}
                        self.data['data'][polyline_id]['parts']= [{'x': [],'y':[],'z':[]}]
                        newline = i #flagging the line where the name of the part is found - next line is #rows/#columns
                    #number of rows/columns
                    elif (inputformat['format'] == 'ldb') and (i == newline+1):
                        print 'number of rows: ' + words[0]
                        print 'number of columns:' + words[1]
                    #data - if nan values discovered, create new part
                    else:
                        #? uncomment the z values if need be in the future [?how could a polygon have z values, unless you enter 2.5D/3D?]
                        if any(float(words[0])==nanvalues) or any(float(words[1])==nanvalues):
                            x = np.nan
                            y = np.nan
                            #z = np.nan
                            line_part_number += 1
                            self.data['data'][polyline_id]['parts'].append({'x': [],'y':[],'z':[]})
                        else:
                            x = float(words[0])
                            y = float(words[1])
                            self.data['data'][polyline_id]['parts'][line_part_number]['x'].append(x)
                            self.data['data'][polyline_id]['parts'][line_part_number]['y'].append(y)
#                            try:
#                                z = float(words[2])
#                                self.data['data'][polyline_id]['parts'][line_part_number]['z'].append(z)
#                            except:
#                                z = np.nan
#                                self.data['data'][polyline_id]['parts'][line_part_number]['z'].append(z)
                        #store to overall data:
                        self.data['data'][polyline_id]['x'].append(x)
                        self.data['data'][polyline_id]['y'].append(y)
                        #self.data['data'][polyline_id]['z'].append(z)
                        
                        #?why another 'i'? Beware of confusing variables!-->Changed it to 'j'
                        #? what is this loop doing??
#                        for j in range(2,len(words)):
#                            self.data['data'][polyline_id][columnname[j]].append(words[j])


